'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var axios = _interopDefault(require('axios'));
var pluralise = _interopDefault(require('pluralize'));
var kitsuCore = require('kitsu-core');

class Kitsu {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (options.camelCaseTypes === false) this.camel = s => s;else this.camel = kitsuCore.camel;
    if (options.resourceCase === 'none') this.resCase = s => s;else if (options.resourceCase === 'snake') this.resCase = kitsuCore.snake;else this.resCase = kitsuCore.kebab;
    if (options.pluralize === false) this.plural = s => s;else this.plural = pluralise;
    this.headers = Object.assign({}, options.headers, {
      Accept: 'application/vnd.api+json',
      'Content-Type': 'application/vnd.api+json'
    });
    this.axios = axios.create(Object.assign({}, {
      baseURL: options.baseURL || 'https://kitsu.io/api/edge',
      timeout: options.timeout || 30000
    }, options.axiosOptions));
    this.fetch = this.get;
    this.update = this.patch;
    this.create = this.post;
    this.remove = this.delete;
    this.interceptors = this.axios.interceptors;
  }

  async get(model) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    try {
      const [res, id, relationship, subRelationship] = model.split('/');
      let url = this.plural(this.resCase(res));
      if (id) url += `/${id}`;
      if (relationship) url += `/${this.resCase(relationship)}`;
      if (subRelationship) url += `/${this.resCase(subRelationship)}`;
      const {
        data
      } = await this.axios.get(url, {
        params,
        paramsSerializer: p => kitsuCore.query(p),
        headers: Object.assign(this.headers, headers)
      });
      return kitsuCore.deserialise(data);
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

  async patch(model, body) {
    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    try {
      const [resourceModel, url] = kitsuCore.splitModel(model, {
        resourceCase: this.resCase,
        pluralModel: this.plural
      });
      const serialData = kitsuCore.serialise(resourceModel, body, 'PATCH', {
        camelCaseTypes: this.camel,
        pluralTypes: this.plural
      });
      const fullURL = body !== null && body !== void 0 && body.id ? `${url}/${body.id}` : url;
      const {
        data
      } = await this.axios.patch(fullURL, serialData, {
        headers: Object.assign(this.headers, headers)
      });
      return kitsuCore.deserialise(data);
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

  async post(model, body) {
    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    try {
      const [resourceModel, url] = kitsuCore.splitModel(model, {
        resourceCase: this.resCase,
        pluralModel: this.plural
      });
      const {
        data
      } = await this.axios.post(url, kitsuCore.serialise(resourceModel, body, 'POST', {
        camelCaseTypes: this.camel,
        pluralTypes: this.plural
      }), {
        headers: Object.assign(this.headers, headers)
      });
      return kitsuCore.deserialise(data);
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

  async delete(model, id) {
    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    try {
      const [resourceModel, url] = kitsuCore.splitModel(model, {
        resourceCase: this.resCase,
        pluralModel: this.plural
      });
      const isBulk = Array.isArray(id);
      let path, payload;

      if (isBulk) {
        path = url;
        payload = id.map(id => ({
          id
        }));
      } else {
        path = `${url}/${id}`;
        payload = {
          id
        };
      }

      const {
        data
      } = await this.axios.delete(path, {
        data: kitsuCore.serialise(resourceModel, payload, 'DELETE', {
          camelCaseTypes: this.camel,
          pluralTypes: this.plural
        }),
        headers: Object.assign(this.headers, headers)
      });
      return data;
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

  async self() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
      const res = await this.get('users', Object.assign({
        filter: {
          self: true
        }
      }, params), headers);
      return res.data[0];
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

  async request(_ref) {
    let {
      body,
      method,
      params,
      type,
      url
    } = _ref;
    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
      var _method;

      method = ((_method = method) === null || _method === void 0 ? void 0 : _method.toUpperCase()) || 'GET';
      const {
        data
      } = await this.axios.request({
        method,
        url,
        data: ['GET', 'DELETE'].includes(method) ? undefined : kitsuCore.serialise(type, body, method, {
          camelCaseTypes: this.camel,
          pluralTypes: this.plural
        }),
        params,
        paramsSerializer: p => kitsuCore.query(p),
        headers: Object.assign(this.headers, headers)
      });
      return kitsuCore.deserialise(data);
    } catch (E) {
      throw kitsuCore.error(E);
    }
  }

}

module.exports = Kitsu;
