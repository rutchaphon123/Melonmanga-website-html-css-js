'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var error = require('./error.js');

function isValid(isArray, type, payload, method) {
  const requireID = new Error(`${method} requires an ID for the ${type} type`);

  if (type === undefined) {
    throw new Error(`${method} requires a resource type`);
  }

  if (isArray) {
    if (method !== 'POST' && payload.length > 0) {
      for (const resource of payload) {
        if (!resource.id) throw requireID;
      }
    }
  } else {
    if (typeof payload !== 'object' || Object.keys(payload).length === 0) {
      throw new Error(`${method} requires an object or array body`);
    }

    if (method !== 'POST' && !payload.id) {
      throw requireID;
    }
  }
}

function serialiseRelationOne(node, relations, key) {
  relations[key] = {
    data: {}
  };

  for (const prop of Object.keys(node[key].data)) {
    const propNode = node[key].data[prop];
    let propRelations = relations[key].data;

    if (prop && !['id', 'type'].includes(prop)) {
      propRelations = serialiseAttr(propNode, prop, propRelations);
    } else propRelations[prop] = propNode;
  }

  return relations;
}

function serialiseRelationMany(node, relations, key) {
  relations[key] = {
    data: []
  };

  for (const prop of node[key].data) {
    relations[key].data.push(prop);
  }

  return relations;
}

function serialiseRelation(node) {
  let relations = {};

  for (const key in node) {
    const isToMany = Array.isArray(node[key].data);
    relations = isToMany ? serialiseRelationMany(node, relations, key) : serialiseRelationOne(node, relations, key);
  }

  return relations;
}

function serialiseObject(node, nodeType, key, data) {
  if (!data.relationships) data.relationships = {};
  if (!node.type) node.type = nodeType;
  data.relationships[key] = {
    data: Object.assign(node)
  };
  data.relationships = serialiseRelation(data.relationships);
  return data;
}

function serialiseArray(node, nodeType, key, data) {
  if (!data.relationships) data.relationships = {};
  data.relationships[key] = {
    data: node.map(_ref => {
      let {
        id,
        type,
        ...attributes
      } = _ref;
      return {
        id,
        type: type || nodeType,
        attributes: Object.keys(attributes).length ? attributes : undefined
      };
    })
  };
  data.relationships = serialiseRelation(data.relationships);
  return data;
}

function serialiseAttr(node, key, data) {
  if (!data.attributes) data.attributes = {};
  data.attributes[key] = node;
  return data;
}

function hasID(node) {
  return Object.prototype.hasOwnProperty.call(node, 'id');
}

function serialiseRootArray(type, payload, method, options) {
  isValid(true, type, payload, method);
  const data = [];

  for (const resource of payload) {
    data.push(serialiseRootObject(type, resource, method, options).data);
  }

  return {
    data
  };
}

function serialiseRootObject(type, payload, method, options) {
  isValid(false, type, payload, method);
  type = options.pluralTypes(options.camelCaseTypes(type));
  let data = {
    type
  };
  if (payload !== null && payload !== void 0 && payload.id) data.id = String(payload.id);

  for (const key in payload) {
    const node = payload[key];
    const nodeType = options.pluralTypes(options.camelCaseTypes(key));

    if (node !== null && (node === null || node === void 0 ? void 0 : node.constructor) === Object && hasID(node)) {
      data = serialiseObject(node, nodeType, key, data);
    } else if (node !== null && Array.isArray(node) && node.length > 0 && hasID(node[0])) {
      data = serialiseArray(node, nodeType, key, data);
    } else if (key !== 'id' && key !== 'type') {
      data = serialiseAttr(node, key, data);
    }
  }

  return {
    data
  };
}

function serialise(type) {
  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  try {
    if (!options.camelCaseTypes) options.camelCaseTypes = s => s;
    if (!options.pluralTypes) options.pluralTypes = s => s;
    if (data === null || Array.isArray(data) && data.length === 0) return {
      data
    };
    if (Array.isArray(data) && (data === null || data === void 0 ? void 0 : data.length) > 0) return serialiseRootArray(type, data, method, options);else return serialiseRootObject(type, data, method, options);
  } catch (E) {
    throw error.error(E);
  }
}

exports.serialise = serialise;
