import { deattribute } from './deattribute.mjs';
import './error.mjs';
import { filterIncludes } from './filterIncludes.mjs';

function link(_ref, included) {
  let {
    id,
    type,
    meta
  } = _ref;
  const filtered = filterIncludes(included, {
    id,
    type
  });
  if (filtered.relationships) linkRelationships(filtered, included);
  if (meta) filtered.meta = meta;
  return deattribute(filtered);
}

function linkArray(data, included, key) {
  data[key] = {};
  if (data.relationships[key].links) data[key].links = data.relationships[key].links;
  data[key].data = [];

  for (const resource of data.relationships[key].data) {
    data[key].data.push(link(resource, included));
  }

  delete data.relationships[key];
}

function linkObject(data, included, key) {
  data[key] = {};
  data[key].data = link(data.relationships[key].data, included);
  if (data.relationships[key].links) data[key].links = data.relationships[key].links;
  delete data.relationships[key];
}

function linkAttr(data, key) {
  data[key] = {};
  if (data.relationships[key].links) data[key].links = data.relationships[key].links;
  delete data.relationships[key];
}

function linkRelationships(data) {
  let included = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const {
    relationships
  } = data;

  for (const key in relationships) {
    var _relationships$key;

    if (Array.isArray((_relationships$key = relationships[key]) === null || _relationships$key === void 0 ? void 0 : _relationships$key.data)) {
      linkArray(data, included, key);
    } else if (relationships[key].data) {
      linkObject(data, included, key);
    } else {
      linkAttr(data, key);
    }
  }

  if (Object.keys(relationships || []).length === 0 && (relationships === null || relationships === void 0 ? void 0 : relationships.constructor) === Object) {
    delete data.relationships;
  }

  return data;
}

export { linkRelationships };
