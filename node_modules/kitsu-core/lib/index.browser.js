(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.kitsuCore = {}));
}(this, (function (exports) { 'use strict';

  function deattribute(data) {
    if (typeof data === 'object' && data !== null) {
      var _data$attributes;

      if (Array.isArray(data)) data.map(el => deattribute(el));else if (((_data$attributes = data.attributes) === null || _data$attributes === void 0 ? void 0 : _data$attributes.constructor) === Object) {
        for (const key of Object.keys(data.attributes)) {
          if (!data.attributes.attributes) {
            data[key] = data.attributes[key];
          }
        }

        if (data.attributes.attributes) {
          data.attributes = data.attributes.attributes;
        } else {
          delete data.attributes;
        }
      }
    }

    return data;
  }

  function error(Error) {
    if (Error.response) {
      const e = Error.response.data;
      if (e !== null && e !== void 0 && e.errors) Error.errors = e.errors;
    }

    throw Error;
  }

  function filterIncludes(included, _ref) {
    let {
      id,
      type
    } = _ref;

    try {
      if (id && type) {
        const filtered = included.filter(el => {
          return el.id === id && el.type === type;
        })[0] || {
          id,
          type
        };
        return Object.assign({}, filtered);
      } else {
        return {};
      }
    } catch (E) {
      error(E);
    }
  }

  function link(_ref, included) {
    let {
      id,
      type,
      meta
    } = _ref;
    const filtered = filterIncludes(included, {
      id,
      type
    });
    if (filtered.relationships) linkRelationships(filtered, included);
    if (meta) filtered.meta = meta;
    return deattribute(filtered);
  }

  function linkArray(data, included, key) {
    data[key] = {};
    if (data.relationships[key].links) data[key].links = data.relationships[key].links;
    data[key].data = [];

    for (const resource of data.relationships[key].data) {
      data[key].data.push(link(resource, included));
    }

    delete data.relationships[key];
  }

  function linkObject(data, included, key) {
    data[key] = {};
    data[key].data = link(data.relationships[key].data, included);
    if (data.relationships[key].links) data[key].links = data.relationships[key].links;
    delete data.relationships[key];
  }

  function linkAttr(data, key) {
    data[key] = {};
    if (data.relationships[key].links) data[key].links = data.relationships[key].links;
    delete data.relationships[key];
  }

  function linkRelationships(data) {
    let included = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const {
      relationships
    } = data;

    for (const key in relationships) {
      var _relationships$key;

      if (Array.isArray((_relationships$key = relationships[key]) === null || _relationships$key === void 0 ? void 0 : _relationships$key.data)) {
        linkArray(data, included, key);
      } else if (relationships[key].data) {
        linkObject(data, included, key);
      } else {
        linkAttr(data, key);
      }
    }

    if (Object.keys(relationships || []).length === 0 && (relationships === null || relationships === void 0 ? void 0 : relationships.constructor) === Object) {
      delete data.relationships;
    }

    return data;
  }

  function deserialiseArray(array) {
    for (let value of array.data) {
      if (array.included) value = linkRelationships(value, array.included);
      if (value.relationships) value = linkRelationships(value);
      if (value.attributes) value = deattribute(value);
      array.data[array.data.indexOf(value)] = value;
    }

    return array;
  }

  function deserialise(response) {
    var _response$data, _response$data2;

    if (!response) return;
    if (Array.isArray(response.data)) response = deserialiseArray(response);else if (response.included) response.data = linkRelationships(response.data, response.included);else if (((_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.constructor) === Object) response.data = linkRelationships(response.data);
    delete response.included;
    if ((_response$data2 = response.data) !== null && _response$data2 !== void 0 && _response$data2.attributes) response.data = deattribute(response.data);
    return response;
  }

  function queryFormat(value, key) {
    if (value !== null && typeof value === 'object') return query(value, key);else return encodeURIComponent(key) + '=' + encodeURIComponent(value);
  }

  function query(params) {
    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const str = [];

    for (const param in params) {
      if (Object.prototype.hasOwnProperty.call(params, param)) {
        str.push(queryFormat(params[param], prefix ? `${prefix}[${param}]` : param));
      }
    }

    return str.join('&');
  }

  function isValid(isArray, type, payload, method) {
    const requireID = new Error(`${method} requires an ID for the ${type} type`);

    if (type === undefined) {
      throw new Error(`${method} requires a resource type`);
    }

    if (isArray) {
      if (method !== 'POST' && payload.length > 0) {
        for (const resource of payload) {
          if (!resource.id) throw requireID;
        }
      }
    } else {
      if (typeof payload !== 'object' || Object.keys(payload).length === 0) {
        throw new Error(`${method} requires an object or array body`);
      }

      if (method !== 'POST' && !payload.id) {
        throw requireID;
      }
    }
  }

  function serialiseRelationOne(node, relations, key) {
    relations[key] = {
      data: {}
    };

    for (const prop of Object.keys(node[key].data)) {
      const propNode = node[key].data[prop];
      let propRelations = relations[key].data;

      if (prop && !['id', 'type'].includes(prop)) {
        propRelations = serialiseAttr(propNode, prop, propRelations);
      } else propRelations[prop] = propNode;
    }

    return relations;
  }

  function serialiseRelationMany(node, relations, key) {
    relations[key] = {
      data: []
    };

    for (const prop of node[key].data) {
      relations[key].data.push(prop);
    }

    return relations;
  }

  function serialiseRelation(node) {
    let relations = {};

    for (const key in node) {
      const isToMany = Array.isArray(node[key].data);
      relations = isToMany ? serialiseRelationMany(node, relations, key) : serialiseRelationOne(node, relations, key);
    }

    return relations;
  }

  function serialiseObject(node, nodeType, key, data) {
    if (!data.relationships) data.relationships = {};
    if (!node.type) node.type = nodeType;
    data.relationships[key] = {
      data: Object.assign(node)
    };
    data.relationships = serialiseRelation(data.relationships);
    return data;
  }

  function serialiseArray(node, nodeType, key, data) {
    if (!data.relationships) data.relationships = {};
    data.relationships[key] = {
      data: node.map(_ref => {
        let {
          id,
          type,
          ...attributes
        } = _ref;
        return {
          id,
          type: type || nodeType,
          attributes: Object.keys(attributes).length ? attributes : undefined
        };
      })
    };
    data.relationships = serialiseRelation(data.relationships);
    return data;
  }

  function serialiseAttr(node, key, data) {
    if (!data.attributes) data.attributes = {};
    data.attributes[key] = node;
    return data;
  }

  function hasID(node) {
    return Object.prototype.hasOwnProperty.call(node, 'id');
  }

  function serialiseRootArray(type, payload, method, options) {
    isValid(true, type, payload, method);
    const data = [];

    for (const resource of payload) {
      data.push(serialiseRootObject(type, resource, method, options).data);
    }

    return {
      data
    };
  }

  function serialiseRootObject(type, payload, method, options) {
    isValid(false, type, payload, method);
    type = options.pluralTypes(options.camelCaseTypes(type));
    let data = {
      type
    };
    if (payload !== null && payload !== void 0 && payload.id) data.id = String(payload.id);

    for (const key in payload) {
      const node = payload[key];
      const nodeType = options.pluralTypes(options.camelCaseTypes(key));

      if (node !== null && (node === null || node === void 0 ? void 0 : node.constructor) === Object && hasID(node)) {
        data = serialiseObject(node, nodeType, key, data);
      } else if (node !== null && Array.isArray(node) && node.length > 0 && hasID(node[0])) {
        data = serialiseArray(node, nodeType, key, data);
      } else if (key !== 'id' && key !== 'type') {
        data = serialiseAttr(node, key, data);
      }
    }

    return {
      data
    };
  }

  function serialise(type) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    try {
      if (!options.camelCaseTypes) options.camelCaseTypes = s => s;
      if (!options.pluralTypes) options.pluralTypes = s => s;
      if (data === null || Array.isArray(data) && data.length === 0) return {
        data
      };
      if (Array.isArray(data) && (data === null || data === void 0 ? void 0 : data.length) > 0) return serialiseRootArray(type, data, method, options);else return serialiseRootObject(type, data, method, options);
    } catch (E) {
      throw error(E);
    }
  }

  function splitModel(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!options.pluralModel) options.pluralModel = s => s;
    if (!options.resourceCase) options.resourceCase = s => s;
    const urlSegments = url.split('/');
    const resourceModel = urlSegments.pop();
    urlSegments.push(options.pluralModel(options.resourceCase(resourceModel)));
    const newUrl = urlSegments.join('/');
    return [resourceModel, newUrl];
  }

  var index = (input => input.replace(/[-_][a-z\u00E0-\u00F6\u00F8-\u00FE]/g, match => match.slice(1).toUpperCase()));

  var index$1 = (input => input.charAt(0).toLowerCase() + input.slice(1).replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '-' + match.toLowerCase()));

  var index$2 = (input => input.charAt(0).toLowerCase() + input.slice(1).replace(/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, match => '_' + match.toLowerCase()));

  exports.camel = index;
  exports.deattribute = deattribute;
  exports.deserialise = deserialise;
  exports.error = error;
  exports.filterIncludes = filterIncludes;
  exports.kebab = index$1;
  exports.linkRelationships = linkRelationships;
  exports.query = query;
  exports.serialise = serialise;
  exports.snake = index$2;
  exports.splitModel = splitModel;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
